#pragma kernel computeGrid
#pragma kernel generatePointCloud
#pragma kernel debugDisplayGridPoints
#pragma kernel genMesh
#pragma kernel filterSolidsPerChunk
#include"claySDF.compute"
RWStructuredBuffer<int> indirectChunkArgs1,indirectChunkArgs2;RWStructuredBuffer<float3> gridData;RWStructuredBuffer<int4> pointCloudData;StructuredBuffer<int> triangleConnectionTable;RWStructuredBuffer<int> indirectDrawArgs,numSolidsPerChunk,updateChunks;struct SolidPerChunk{int solids[512];};RWStructuredBuffer<SolidPerChunk> solidsPerChunk;struct PrefilteredSolidSlice{int solids[128];};RWStructuredBuffer<PrefilteredSolidSlice> prefilteredSolidIds;
#if DRAW_DEBUG
RWStructuredBuffer<float3> debugGridOutPoints;
#endif
StructuredBuffer<float3> solidsPos;StructuredBuffer<float4> solidsRot;StructuredBuffer<float3> solidsScale;StructuredBuffer<float> solidsBlend;StructuredBuffer<int> solidsType;StructuredBuffer<float3> solidsColor;StructuredBuffer<float4> solidsAttrs;StructuredBuffer<int> solidsClayObjectId,solidsUpdated;RWStructuredBuffer<int3> meshOutIndices;RWStructuredBuffer<float3> meshOutPoints;RWStructuredBuffer<float4> meshOutColors;uint chunkId=0,numSolids=0,numSolidsBlending=0;float chunkSize=20.;float3 chunkCenter=float3(0.,0.,0.);int numChunksX=0,numChunksY=0,numChunksZ=0,outMeshIndexOffset=0;float solidsMaxInfluence=0.;uint numSolidsUpdated=0;int retopo=0;static const int3 localGridCellCoords[8]={int3(0,0,0),int3(1,0,0),int3(1,1,0),int3(0,1,0),int3(0,0,1),int3(1,0,1),int3(1,1,1),int3(0,1,1)};static const float3 vertexOffset[8]={float3(0,0,0),float3(1,0,0),float3(1,1,0),float3(0,1,0),float3(0,0,1),float3(1,0,1),float3(1,1,1),float3(0,1,1)};static const int2 edgeConnection[12]={int2(0,1),int2(1,2),int2(2,3),int2(3,0),int2(4,5),int2(5,6),int2(6,7),int2(7,4),int2(0,4),int2(1,5),int2(2,6),int2(3,7)};static const float3 edgeDirection[12]={float3(1.f,0.f,0.f),float3(0.f,1.f,0.f),float3(-1.f,0.f,0.f),float3(0.f,-1.f,0.f),float3(1.f,0.f,0.f),float3(0.f,1.f,0.f),float3(-1.f,0.f,0.f),float3(0.f,-1.f,0.f),float3(0.f,0.f,1.f),float3(0.f,0.f,1.f),float3(0.f,0.f,1.f),float3(0.f,0.f,1.f)},cardinalCellOffset[8]={float3(-1,-1,-1),float3(1,-1,-1),float3(1,1,-1),float3(-1,1,-1),float3(-1,-1,1),float3(1,-1,1),float3(1,1,1),float3(-1,1,1)};static const int cubeEdgeFlags[]={0,265,515,778,1030,1295,1541,1804,2060,2309,2575,2822,3082,3331,3593,3840,400,153,915,666,1430,1183,1941,1692,2460,2197,2975,2710,3482,3219,3993,3728,560,825,51,314,1590,1855,1077,1340,2620,2869,2111,2358,3642,3891,3129,3376,928,681,419,170,1958,1711,1445,1196,2988,2725,2479,2214,4010,3747,3497,3232,1120,1385,1635,1898,102,367,613,876,3180,3429,3695,3942,2154,2403,2665,2912,1520,1273,2035,1786,502,255,1013,764,3580,3317,4095,3830,2554,2291,3065,2800,1616,1881,1107,1370,598,863,85,348,3676,3925,3167,3414,2650,2899,2137,2384,1984,1737,1475,1226,966,719,453,204,4044,3781,3535,3270,3018,2755,2505,2240,2240,2505,2755,3018,3270,3535,3781,4044,204,453,719,966,1226,1475,1737,1984,2384,2137,2899,2650,3414,3167,3925,3676,348,85,863,598,1370,1107,1881,1616,2800,3065,2291,2554,3830,4095,3317,3580,764,1013,255,502,1786,2035,1273,1520,2912,2665,2403,2154,3942,3695,3429,3180,876,613,367,102,1898,1635,1385,1120,3232,3497,3747,4010,2214,2479,2725,2988,1196,1445,1711,1958,170,419,681,928,3376,3129,3891,3642,2358,2111,2869,2620,1340,1077,1855,1590,314,51,825,560,3728,3993,3219,3482,2710,2975,2197,2460,1692,1941,1183,1430,666,915,153,400,3840,3593,3331,3082,2822,2575,2309,2060,1804,1541,1295,1030,778,515,265,0};int f(int f,int i,int s,int c){return f+c*(i+c*s);}uint f(float3 f){uint s=uint(f.x*255)+uint(f.y*255)*256+uint(f.z*255)*256*256;return s;}float f(float f,float i,float s){float c=max(s-abs(f-i),0.);return min(f,i)-c*c*.25f/s;}float s(float f,float i,float s){float e=abs(s),c=max(e-abs(-f-i),0.);return max(-f,i)+c*c*.25/e;}bool f(int4 s,int f){if(f>128)return false;uint e=uint(f)/32;int i=s[e],u=f-32*e;if(i>>u&1)return true;return false;}void s(uint f,inout int4 s){uint e=f/32;int i=s[e],u=f-32*e;i=i&~(1<<u);if(e==0)s.x=i;else if(e==1)s.y=i;else if(e==2)s.z=i;else if(e==3)s.w=i;}bool s(int f){return f>>0&1;}float f(float3 i,float c,inout int4 u,float S,uint e,uint x){float z=1e+10;int t=0;for(uint r=0;r<e;++r){if(!f(u,r)){continue;}uint g=prefilteredSolidIds[x].solids[r];float M=solidsBlend[g];float4 m=solidsAttrs[g];float y=computeClayDistanceFunction(solidsType[g],i,solidsPos[g],solidsRot[g],solidsScale[g],m);if(!s(m.w)){if(M==0.)z=min(y,z);else if(M>0.)z=f(y,z,M);else z=s(y,z,M);}if(y>S)s(r,u);S-=abs(M);}return z;}float f(float3 i,float c,out int z,out float3 u,int4 y,uint e,uint g){float r=1e+10;u=float3(1.,1.,1.);for(uint x=0;x<e;++x){if(!f(y,x)){continue;}uint t=prefilteredSolidIds[g].solids[x];float M=solidsBlend[t];float3 m=solidsColor[t];float4 n=solidsAttrs[t];float S=computeClayDistanceFunction(solidsType[t],i,solidsPos[t],solidsRot[t],solidsScale[t],n);if(S<r)z=t;bool d=s(n.w);if(M==0.){float o=clamp((r-S)/(c*2.),0.,1.);u=lerp(u,m,o);if(!d)r=min(S,r);}else if(M>0.){float o=clamp(.5+.5*(S-r)/M,0.,1.);u=lerp(m,u,o);if(!d)r=f(S,r,M);}else{float o=clamp(.5+.5*(-S-r)/M,0.,1.);u=lerp(m,u,o);if(!d)r=s(S,r,M);if(o<.5)z=t;}}return r;}float f(float3 i,float y,out int z,out float3 r,int4 u){float e=1e+10;r=float3(1.,1.,1.);int c=0;for(uint t=0;t<numSolids;++t){if(!f(u,t)){continue;}c+=1;float M=solidsBlend[t];float3 g=solidsColor[t];float S=computeClayDistanceFunction(solidsType[t],i,solidsPos[t],solidsRot[t],solidsScale[t],solidsAttrs[t]);if(S<e)z=t;if(M==0.)e=min(S,e);else if(M>0.)e=f(S,e,M);else e=s(S,e,M);}float M=float(c-1)/float(numSolids-1);r=lerp(float3(0.,0.,1.),float3(1.,0.,0.),M);return e;}float3 r(int f){int i=(f&255)>>0,e=(f&65280)>>8,M=(f&16711680)>>16;return float3(i/255.,e/255.,M/255.);}bool t(int3 f){if(f.x<0)return true;if(f.x>255)return true;if(f.y<0)return true;if(f.y>255)return true;if(f.z<0)return true;if(f.z>255)return true;return false;}float i(int4 f){float e=0.;for(uint i=0;i<numSolids;++i)e+=abs(solidsBlend[i]);return e;}float3 i(int3 f,float i){float e=i*.5,M=chunkSize*.5;float3 s=float3(i*f.x-M,i*f.y-M,i*f.z-M)+e;return s;}void i(float3 f,float i,uint t,inout uint e,inout float s){uint c=numSolidsPerChunk[chunkId],r=0;for(r=0;r<c;++r){uint g=solidsPerChunk[chunkId].solids[r];float3 u=solidsScale[g],M=f;if(int(solidsAttrs[g].w)>>1&1)M.x=abs(M.x);float z=max(u.x,max(u.y,u.z))*1.732,o=length(solidsPos[g]-M)-z;if(o<2.){prefilteredSolidIds[t].solids[e]=g;e+=1;s+=abs(solidsBlend[g]);if(e==128){break;}}}}[numthreads(MAXTHREADS,MAXTHREADS,MAXTHREADS)]void computeGrid(int3 s:SV_DispatchThreadID){float c=chunkSize/64;float3 e=i(s,c);int M=f(s.x,s.y,s.z,64);if(M==0)indirectDrawArgs[0]=0;uint u=0;float r=0.;i(e+chunkCenter,c*.5,M,u,r);float t=c*.25,z=t*.5,o=c*.5,x=chunkSize/256,g=chunkSize*.5;int4 y=int4(-1,-1,-1,-1);float S=f(e+chunkCenter,c,y,r+c,u,M);for(uint m=0;m<8;++m){float3 d=e+t*cardinalCellOffset[m];for(uint n=0;n<8;++n){float3 v=d+z*cardinalCellOffset[n];int3 k=int3(round((v.x+g-z)/x),round((v.y+g-z)/x),round((v.z+g-z)/x));int p=f(k.x,k.y,k.z,256);gridData[p]=float3(0,0,0);if(abs(S)<c){int D=0;float3 w=float3(1.,1.,1.);float a=f(v+chunkCenter,z,D,w,y,u,M);if(abs(a)<o){int l=solidsClayObjectId[D]+1;gridData[p]=float3(a,f(w),l);}}}}}float r(float f,float s){float e=s-f,i=.5;if(e!=0.)i=f/e;return i;}float2 c(float2 f){float2 e=f.xy>=0.?1.:-1.,i=(1.-abs(f.yx))*e;return i;}float m(float2 f){int i=2048;float c=floor(f.x*(i-1)),e=floor(f.y*(i-1)),s=c*i+e;return s;}float d(float3 f){f/=abs(f.x)+abs(f.y)+abs(f.z);f.xy=f.z>=0.?f.xy:c(f.xy);f.xy=f.xy*.5+.5;float t=m(f.xy);return t;}int c(uint f,uint i,uint r,uint s){int t=f<<24|i<<16|r<<8|s;return t;}float u(float3 f){float t=dot(round(f*255),float3(65536,256,1));return t;}groupshared int4 gs_pointCloudData[256];groupshared uint gs_numElements,gs_globalOffset;void c(int3 i,float e,int s){int t=f(i.x,i.y,i.z,256);float3 M=gridData[t];if(M.z==0.){return;}float n[8];int g=0;for(int x=0;x<8;++x){int3 z=i+localGridCellCoords[x];int m=f(z.x,z.y,z.z,256);float3 S=gridData[m];if(S.z==0.){return;}n[x]=S.x;if(S.x<=0.)g|=1<<x;}int z=cubeEdgeFlags[g];if(z==0){return;}float3 m=i;int y=g*16,a[3]={triangleConnectionTable[y+3],triangleConnectionTable[y+4],triangleConnectionTable[y+5]};float3 S=float3(0,0,0),o[3];int v;for(v=0;v<3;++v){int p=a[v];float k=n[edgeConnection[p].x],w=n[edgeConnection[p].y],X=r(k,w);float3 l=m+(vertexOffset[edgeConnection[p].x]-X*edgeDirection[p])*e;o[v]=l;S+=l;}float3 k=cross(o[2]-o[0],o[1]-o[0]);if(abs(k.x+k.y+k.z)>0.){a[0]=triangleConnectionTable[y];a[1]=triangleConnectionTable[y+1];a[2]=triangleConnectionTable[y+2];for(v=0;v<3;++v){int p=a[v];float D=n[edgeConnection[p].x],w=n[edgeConnection[p].y],X=r(D,w);float3 l=m+(vertexOffset[edgeConnection[p].x]-X*edgeDirection[p])*e;o[v]=l;}k+=cross(o[2]-o[0],o[1]-o[0]);a[0]=triangleConnectionTable[y+6];a[1]=triangleConnectionTable[y+7];a[2]=triangleConnectionTable[y+8];for(v=0;v<3;++v){int p=a[v];float D=n[edgeConnection[p].x],w=n[edgeConnection[p].y],X=r(D,w);float3 l=m+(vertexOffset[edgeConnection[p].x]-X*edgeDirection[p])*e;o[v]=l;}k+=cross(o[2]-o[0],o[1]-o[0]);a[0]=triangleConnectionTable[y+9];a[1]=triangleConnectionTable[y+10];a[2]=triangleConnectionTable[y+11];for(v=0;v<3;++v){int p=a[v];float D=n[edgeConnection[p].x],w=n[edgeConnection[p].y],X=r(D,w);float3 l=m+(vertexOffset[edgeConnection[p].x]-X*edgeDirection[p])*e;o[v]=l;}k+=cross(o[2]-o[0],o[1]-o[0]);k=normalize(k);S/=3;float3 D=(S-m)/e;uint w=uint(u(D));float l=d(k);int p=M.y,X=M.z;if(X>255)X=255;int P=0;InterlockedAdd(gs_numElements,1,P);gs_pointCloudData[P]=int4(c(i.x,i.y,i.z,X),w,l,p);}}[numthreads(MAXTHREADS,MAXTHREADS,MAXTHREADS)]void generatePointCloud(int3 f:SV_DispatchThreadID,uint i:SV_GroupIndex){if(i==0)gs_numElements=0,gs_globalOffset=0;GroupMemoryBarrierWithGroupSync();float s=chunkSize/256;c(f,s,i);GroupMemoryBarrierWithGroupSync();if(i==0)InterlockedAdd(indirectDrawArgs[0],gs_numElements*3,gs_globalOffset),gs_globalOffset/=3;GroupMemoryBarrierWithGroupSync();if(i<gs_numElements)pointCloudData[gs_globalOffset+i]=gs_pointCloudData[i];}[numthreads(MAXTHREADS,MAXTHREADS,MAXTHREADS)]void debugDisplayGridPoints(int3 s:SV_DispatchThreadID){
#if DRAW_DEBUG
int t=f(s.x,s.y,s.z,256);if(gridData[t].z!=0.){int e=debugGridOutPoints.IncrementCounter();float M=chunkSize/256;debugGridOutPoints[e]=i(s,M)+chunkCenter;}
#endif
}float4 g(uint f){int i=(f&255)>>0,M=(f&65280)>>8,e=(f&16711680)>>16;return float4(i/255.,M/255.,e/255.,1.);}[numthreads(MAXTHREADS,MAXTHREADS,MAXTHREADS)]void genMesh(int3 s:SV_DispatchThreadID){float e=chunkSize/256;int t=f(s.x,s.y,s.z,256);float3 c=gridData[t];if(retopo==0){if(c.z==0.){return;}}float n[8];int p=0,M=0;for(int x=0;x<8;++x){int3 u=s+localGridCellCoords[x];if(u.x<0||u.y<0||u.z<0||u.x>255||u.y>255||u.z>255){return;}int y=f(u.x,u.y,u.z,256);float3 m=gridData[y];n[x]=m.x;if(m.z==0.){if(retopo==0){M+=1;if(M>1){return;}}else{continue;}}if(m.x<0.)p|=1<<x;}int u=cubeEdgeFlags[p];if(u<0){return;}float3 m=i(s,e),a[12];for(int v=0;v<12;++v){if((u&1<<v)!=0){float S=n[edgeConnection[v].x],z=n[edgeConnection[v].y],o=r(S,z);a[v]=m+(vertexOffset[edgeConnection[v].x]-o*edgeDirection[v])*e;}}int y=p*16;for(int z=0;z<5;++z){int k=3*z;if(triangleConnectionTable[y+k]>=0){uint S=meshOutIndices.IncrementCounter();for(int o=0;o<3;++o){int D=triangleConnectionTable[y+k+o],l=meshOutPoints.IncrementCounter(),w=c.y;meshOutPoints[l]=a[D]+chunkCenter;meshOutColors[l]=g(w);meshOutIndices[S][2-o]=l+outMeshIndexOffset;}}}}[numthreads(1,1,1)]void filterSolidsPerChunk(int3 f:SV_DispatchThreadID){int t=f.x+f.y*numChunksX+numChunksX*numChunksY*f.z;float i=chunkSize/256.f,e=chunkSize-i,M=chunkSize*.5;float3 s=float3(-(chunkSize*numChunksX*.5)+M+e*f.x,-(chunkSize*numChunksY*.5)+M+e*f.y,-(chunkSize*numChunksZ*.5)+M+e*f.z);float z=chunkSize*1.732*.5;int p=t*3,u=updateChunks[t]-1,g=0;for(uint r=0;r<numSolids;++r){float3 c=solidsScale[r];float o=max(c.x,max(c.y,c.z))*1.732;float3 S=s;if(checkMirrorX(solidsAttrs[r].w))S.x=abs(S.x);float v=length(solidsPos[r]-S)-o;if(v<z){solidsPerChunk[t].solids[g]=r;g+=1;if(u<=0){for(uint x=0;x<numSolidsUpdated;++x){uint m=solidsUpdated[x];if(m==r){u=1;break;}}}}}uint c=0,m=0;if(u>-1)c=64/MAXTHREADS,m=256/MAXTHREADS;updateChunks[t]=u;indirectChunkArgs1[p]=c;indirectChunkArgs1[p+1]=c;indirectChunkArgs1[p+2]=c;indirectChunkArgs2[p]=m;indirectChunkArgs2[p+1]=m;indirectChunkArgs2[p+2]=m;numSolidsPerChunk[t]=g;}